use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

fn main() {
    let responses_dir = Path::new("..").join("responses");

    // Tell Cargo to re-run this build script if any response file changes.
    println!(
        "cargo:rerun-if-changed={}",
        responses_dir.display()
    );

    let mut entries: Vec<(u16, Vec<String>)> = fs::read_dir(&responses_dir)
        .expect("failed to read responses directory")
        .filter_map(|e| e.ok())
        .filter_map(|e| {
            let name = e.file_name();
            let name = name.to_string_lossy();
            if !name.ends_with(".json") {
                return None;
            }
            let code_str = name.trim_end_matches(".json");
            let code: u16 = code_str.parse().ok()?;
            let data = fs::read_to_string(e.path()).ok()?;
            let messages: Vec<String> = serde_json::from_str(&data).ok()?;
            if messages.is_empty() {
                return None;
            }
            Some((code, messages))
        })
        .collect();

    entries.sort_by_key(|(code, _)| *code);

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let out_path = out_dir.join("responses_data.rs");
    let mut f = fs::File::create(&out_path).expect("failed to create responses_data.rs");

    writeln!(f, "// Generated by build.rs from responses/*.json â€” DO NOT EDIT.").unwrap();
    writeln!(f).unwrap();
    writeln!(
        f,
        "pub(crate) static RESPONSES: &[(u16, &[&str])] = &["
    )
    .unwrap();

    for (code, messages) in &entries {
        writeln!(f, "    ({code}, &[").unwrap();
        for msg in messages {
            // Escape backslashes and double-quotes for a Rust string literal.
            let escaped = msg.replace('\\', "\\\\").replace('"', "\\\"");
            writeln!(f, "        \"{escaped}\",").unwrap();
        }
        writeln!(f, "    ]),").unwrap();
    }

    writeln!(f, "];").unwrap();
}
